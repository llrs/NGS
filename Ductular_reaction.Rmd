---
title: "Ductular Reaction"
author: "[Llu√≠s Revilla](mailto:lrevilla@clinic.cat)"
date: "`r Sys.Date()`"
output:
  BiocStyle::html_document:
    toc: true
  BiocStyle::pdf_document:
    toc: true
---

```{r setup, echo=FALSE, results="asis", message=FALSE}
knitr::opts_chunk$set(tidy = FALSE, echo = TRUE, cache = TRUE, autodep = TRUE)
```
This is part of a bigger study you can find [here](index.html)

# Ductular Reaction

This data was extracted from a liver, the POS labels indicate that were extracted from a microdisection with KRT7 positive. NEG indicates that for the same microdisection those not stained for KRT7 where taken. TOTAL indicates that there is a mix of KRT7+ and KRT7- dyeing. Also this data has been already normalized.

## Load the data of ductular reaction

```{r load}
phenoData <- read.csv("../data/ductular_reaction/PHENO_26_10_2015.csv", row.names = 1)
expression <- read.delim("../data/ductular_reaction/refseq_counts_DR.csv", row.names = 1)
```
We explore these data:

```{r exploration, message = FALSE}
library("geneplotter")
summary(phenoData)
phenoData
expression[1:5, 1:5]
```
We can observe the expression uses the RefSeq identifier of NCBI. 

We can calculate the normalization factors used to calculate the Counts per million read: 
```{r calcNormFactors}
library("edgeR")
dge <- DGEList(counts = expression, group = phenoData$G)
ord <- order(dge$sample$lib.size)
barplot(dge$sample$lib.size[ord]/1e6, las = 1, ylab = "Millions of reads",
        xlab = "Samples", main = "Library size of the samples", col = phenoData$G)
legend("topleft", legend = unique(phenoData$G), fill = unique(phenoData$Status))
dge <- calcNormFactors(dge)
```
We can normalize the data to counts per millon of reads taking into account that we know the normalized library size:
```{r cpm}
logCPM <- cpm(dge, normalized.lib.sizes = TRUE, log = TRUE, prior.count = 3)
```
## Check quality pre-normalizations
We can observe the quality of the samples with a boxplot and the density of expressions:
```{r q_check, fig.width = 30}
boxplot(logCPM, main = "Expression per sample", col = phenoData$G)
multidensity(logCPM, main = "Densities of expression", legend = NULL,  
             col = phenoData$G)
avgexp <- rowMeans(expression)
hist(avgexp, main = "Histogram of mean expression per gene")
abline(v = 1, col = "red", lwd = 2)
```
There is a lot of differences between samples on the low expressed genes. We filter those genes that are below 1, as they are unreliable:

```{r remove}
logCPM <- logCPM[avgexp > 1, ]
multidensity(logCPM, main = "Densities of expression", legend = NULL)
```
Now the distribution of the expression between samples is much more comparable. 
Following the recomendation of the edgeR package we recalculate the normalization factor without the lowly expressed genes:

```{r recalc, message = FALSE}
dge <- calcNormFactors(dge[avgexp > 1, ])
logCPM <- cpm(dge, normalized.lib.sizes = TRUE, log = TRUE, prior.count = 3)
```
We can check how has this normalization affected the values:
```{r q_check2}
boxplot(logCPM, main = "Expression per sample", col = phenoData$G)
multidensity(logCPM, main = "Densities of expression", legend = NULL)
avgexp <- rowMeans(logCPM)
hist(avgexp, main = "Histogram of mean expression per gene")
```
Now are a little bit more comparable.  
To work easier with the data I proceed to create an ExpressionSet

```{r ESet, message = FALSE}
library("Biobase")
library("AnnotationDbi")
DR <- ExpressionSet(as.matrix(logCPM))
phenoData(DR) <- AnnotatedDataFrame(phenoData)
DR
```

## Check the normalizations applied 
We take advantatge of the plotMDS function of limma package to plot the MDS of the samples, to see how close are between them. 

```{r plotMDS, message=FALSE }
plotMDS(DR, top = Inf, labels = phenoData(DR)$G, main = "Samples relationships")
```

## Design
In this case each type of expression has come from a different subset of the liver, so we should consider each one as an independent group. 
```{r design}
design <- model.matrix(~0 + phenoData(DR)$G)
colnames(design) <- c("NEG", "POS", "TOTAL")
design
```

And we can adjust the data using the weights previously calculated and the design we just created:
```{r voom}
v <- voom(dge, design, plot = TRUE, normalize.method = "cyclicloess")
```

## Estimate surrogate variables
We can further estimate surrogate variables with the package sva:
```{r sva, message = FALSE}
library("sva")
sv <- sva(v$E, design)
```
We can append the estimated surrogated variables to the design matrix for a better estimation of the effect of each paramter:

```{r cbind_design}
i.design <- cbind(design, sv$sv)
colnames(i.design) <- c(colnames(design), paste0("X", 1:ncol(sv$sv)))
```

We fit the design with the expression of the ductular reaction:

```{r fitting}
fit <- lmFit(v$E, i.design)
```

## Contrasts
We are interested in the Positive vs Negative comparison, but we can compute others too:
```{r comp}
contrasts <- makeContrasts("PosVsNeg" = POS - NEG,
                           "PosVsTotal" = POS - TOTAL,
                           "NegVsTotal" = NEG - TOTAL, 
                           levels = i.design)
contrasts
```

```{r contrast_fit2}
fit.2 <- contrasts.fit(fit, contrasts)
fit.2 <- eBayes(fit.2, proportion = 0.1)
results.DR <- decideTests(fit.2, adjust.method = "fdr", lfc = log2(2))
summary(results.DR)
```

We can observe the quality of the t values over the teoretical quantiles to observe if there is any assumption about the eBayes fitting which doesn't holds. Note that I already modified the expected proportion of genes in the call to eBayes:
```{r qualtiy2, fig.width = 30, fig.height = 30 }
par(mfrow = c(3, 3))
out <- sapply(colnames(results.DR), function(x){
  qqt(fit.2$t[, x], df = fit.2$df.total, main = paste("Student's t Q-Q Plot of", x))
  abline(0, 1)
  volcanoplot(fit.2, coef = x, main = x)
  plotMD(fit.2, coef = x, main = x)
})

```

## Store the data

```{r store_DR}
save(fit, fit.2, design, DR, contrasts, file = "DR.RData")
```

## Differentially expressed genes
```{r DEG_RD, fig.width = 14, fig.height = 30 }
tt.DR <- topTable(fit.2, coef = "PosVsNeg", sort.by = "logFC", number = Inf)
tt.DR <- tt.DR[order(-abs(tt.DR$logFC)), ] # Ordered by the absolute value of logFC
signif <- tt.DR[tt.DR$adj.P.Val < 0.05, ] # Subset of significant p-value
par(mfrow = c(2, 1))
plot(density(signif[1:2000, "logFC"]), main = "Distribution of the top 2000 DEG")
hist(signif[1:2000, "logFC"], main = "Distribution of the top 2000 DEG")
```
## Functional enrichment

### topGO 
We can also group them by GO:
```{r topGO}
library("topGO")
allGenes <- tt.DR[, "adj.P.Val"]
names(allGenes) <- rownames(tt.DR)
topDiffGenes <- function(x) {
  return(x <= 0.05)
}
GOdata.bp <- new("topGOdata",
                 ontology = "BP",
                 description = "Biological process of the signature module.",
                 allGenes = allGenes,
                 annot = annFUN.org,
                 ID = "symbol",
                 mapping = "org.Hs.eg",
                 geneSel = topDiffGenes,
                 nodeSize = 5)
save(GOdata.bp, file = "GO_ALD.RData")
resultFisher <- runTest(GOdata.bp, algorithm = "classic", statistic = "fisher")
resultKS.weight <- runTest(GOdata.bp, algorithm = 'weight01', statistic = "ks")
resultKS.elim <- runTest(GOdata.bp, algorithm = "elim", statistic = "ks")
avgResult <- combineResults(resultFisher, resultKS.weight, resultKS.elim,
                            method = "mean")

allRes <- GenTable(GOdata.bp, classic = resultFisher, weight01 = resultKS.weight,
                   elim = resultKS.elim, orderBy = "weight01", topNodes = 1000)
allRes <- allRes[allRes$weight01 < 0.05, ]
write.csv(allRes, file = "GO_DR.csv", row.names = FALSE)

showSigOfNodes(GOdata.bp, score(resultKS.weight), firstSigNodes = 10, useInfo = 'all')
title(main = "GO analysis using Weight01 algorithm")
```
In this plot we can observe the relationship between the top 10 significant gene ontologies, using the Weight01 algorithm.
# SessionInfo

```{r end}
sessionInfo()
```
